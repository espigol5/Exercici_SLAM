
% State and measurement sizes
pose_size= 3;
motion_size= 3;
lmk_size= 2;

%
num_poses_states= 3; 
num_lmks_states= 4;
num_poses_factor= 1;
num_lmks_factor= 8;
num_motion_factor= 2;

torad= pi/180;

% Factors
factor{1+ 0 }= struct(... % link 0 (Dibuix de la sessió 3 del 09/02/19)
    'type', 'pose', ...
    'measurement', [0;0;0], ...
    'covariance', 1e-3*eye(3,3), ...
    'index', 0);

factor{1+ 1 }= struct(... %link 1
    'type', 'motion', ...
    'measurement', [1.0;0.0;-5*torad], ...
    'covariance', diag([1e-2, 1e-2, (5*torad)^2]), ...
    'index', [0,1]);

factor{1+ 2 }= struct(...
    'type', 'motion', ...
    'measurement', [1.05;-0.05;-3*pi/180], ...
    'covariance', diag([1e-2, 1e-2, (5*torad)^2]), ...
    'index', [1,2]);

factor{1+ 3 }= struct(...
    'type', 'lmk', ...
    'measurement', [1.2;40*torad], ... % Angle de 40 graus, és aproximat amb la x teorica i langle fins el link. Només 2 variables al measurement pk és distancia i angle només                                      
    'covariance', diag([1e-2, (10*torad)^2]), ...
    'index', [0,3]);

factor{1+ 4 }= struct(...
    'type', 'lmk', ...
    'measurement', [0.85; 95*torad], ...
    'covariance', diag([1e-2, (5*torad)^2]), ...
    'index', [1, 3]);

factor{1+ 5} = struct(...
    'type' , 'lmk',...
    'measurement', [1.30; 25*torad],...
    'covariance', diag([1e-2,(10*torad)^2]),...
    'index', [1,4]);

factor{1+ 6} = struct(...
    'type' , 'lmk',...
    'measurement', [1.45; 40*torad],...
    'covariance', diag([1e-2,(20*torad)^2]),...
    'index', [0,5]);

factor{1+ 7} = struct(...
    'type' , 'lmk',...
    'measurement', [0.8; -70*torad],...
    'covariance', diag([1e-2,(10*torad)^2]),...
    'index', [1,5]);

factor{1+ 8} = struct(...
    'type' , 'lmk',...
    'measurement', [2.5; -40*torad],...
    'covariance', diag([2e-2,(7*torad)^2]),...
    'index', [0,6]);

factor{1+ 9} = struct(...
    'type' , 'lmk',...
    'measurement', [1.5; -30*torad],...
    'covariance', diag([3e-2,(10*torad)^2]),...
    'index', [1,6]);

factor{1+ 10} = struct(...
    'type' , 'lmk',...
    'measurement', [0.9; -35*torad],...
    'covariance', diag([2e-2,(10*torad)^2]),...
    'index', [2,6]);

% States
states{1+ 0 }= struct(...
    'type', 'pose', ...
    'range', [1;2;3], ... % Marca les dimensions, x, y, theta, en aquest cas
    'value', [0;0;0]);

states{1+ 1 }= struct(...
    'type', 'pose', ...
    'range', [4;5;6], ... 
    'value', [0;0;0]);

states{1+ 2 }= struct(...
    'type', 'pose', ...
    'range', [7;8;9], ... 
    'value', [0;0;0]);

states{1+ 3 }= struct(...
    'type', 'lmk', ...
    'range', [10;11], ... 
    'value', [1;0]);

states{1+ 4 }= struct(...
    'type', 'lmk', ...
    'range', [12;13], ... 
    'value', [1;0]);

states{1+ 5 }= struct(...
    'type', 'lmk', ...
    'range', [14;15], ... 
    'value', [1;0]);

states{1+ 6 }= struct(...
    'type', 'lmk', ...
    'range', [16;17], ... 
    'value', [1;0]);

dx= ones(17, 1) * 1e6;
eps= 1e-6;

while norm(dx) > eps

    [A, r]= buildproblem(states, factor);
    dx= solvelinearized(A, r);
    
    states= updatestates(states, dx);
    
    drawmap(states, factor);    

end















